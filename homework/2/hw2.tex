\documentclass{article}
\topmargin = 0in
\oddsidemargin = 0in
\evensidemargin = \oddsidemargin
\textwidth = 6.5in
\textheight = 8in
\usepackage{times}
\usepackage{bcprules}
\usepackage{amsthm}
\usepackage{syntax}
\usepackage{trfrac}
\usepackage{mathtools}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\newcommand{\step}[2]{{\tt #1} $\longrightarrow$ {\tt #2}}
\newcommand{\eval}[2]{{\tt #1} $\Downarrow$ {\tt #2}}
\newcommand{\tc}[3]{{\tt #1} $\vdash$ {\tt #2} \ : \ {\tt #3}}
\newcommand{\tcDef}[2]{{\tt #1}\ : \ {\tt #2}}

\newcommand{\inferrule}[3]{\infrule[#1]{\mbox{#2}}{\mbox{#3}}}
\newcommand{\inferax}[2]{\infrule[#1]{\mbox{}}{\mbox{#2}}}


\title{Homework 2}

\author{John Bender and Lorenzo Gomez, CS 231}

\date{October 17th, 2013}

\newtheorem{free}{Free Variables}
\newtheorem{deter}{Determinism}
\newtheorem{thm}{Theorem}

\begin{document}

\maketitle

\begin{enumerate}
  \item Call-by-value Lambda Calculus
    \begin{enumerate}
    \item $x\ (\lambda x.x)$
    \item $((\lambda x.x)\ \lambda y.y)\ r)\ (\lambda q.q)$ $\longrightarrow$ $((\lambda y.y)\ r)\ (\lambda q.q)$ $\longrightarrow$ $r\ (\lambda q.q)$ \\
    \item $(\lambda x.x\ (\lambda y.y\ (\lambda z.z\ \lambda n.n)))\ (\lambda w. w \ \lambda r.r)$ \\
      \begin{equation*}
        \trfrac[E-App1]{
          \trfrac[E-App2]{
            \trfrac[E-App2]{
              \trfrac[E-AppBeta]{}{
                \lambda z.z\ \lambda n.n \longrightarrow \lambda n.n
              }
            }{
              \lambda y.y\ (\lambda z.z\ \lambda n.n) \longrightarrow \lambda y.y\ \lambda n.n
            }
          }{
            \lambda x.x\ (\lambda y.y\ (\lambda z.z\ \lambda n.n)) \longrightarrow \lambda x.x\ (\lambda y.y\ \lambda n.n)
          }
        }{
          (\lambda x.x\ (\lambda y.y\ (\lambda z.z\ \lambda n.n)))\ \lambda w.w \longrightarrow
          (\lambda x.x\ (\lambda y.y\ \lambda n.n))\ \lambda w.w
        }
      \end{equation*}
    \end{enumerate}

    \vspace{0.5cm}

  \item{Stepping with call-by-value}
    \begin{enumerate}
    \item $(\lambda x.x\ x)\ ((\lambda y.y\ y)\ (\lambda z.z))$ $\longrightarrow$ \\
      $(\lambda x.x\ x)\ ((\lambda z.z)\ (\lambda z.z))$ $\longrightarrow$ \\
      $(\lambda x.x\ x)\ (\lambda z.z)$ $\longrightarrow$ \\
      $(\lambda z.z)\ (\lambda z.z)$ $\longrightarrow$ \\
      $(\lambda z.z)$

    \item $(\lambda x.\ (x\ (\lambda z.x\ z)))\ (\lambda x.x\ y\ x)$ $\longrightarrow$ \\
      $(\lambda x.x\ y\ x)\ (\lambda z.(\lambda x.x\ y\ x)\ z)\ $
      $\longrightarrow$  \\
      $(\lambda z.(\lambda x.x\ y\ x)\ z)\ y\ (\lambda z.(\lambda x.x\ y\ x)\ z)$
      $\longrightarrow$  \\
      $((\lambda x.x\ y\ x)\ y)\ (\lambda z.(\lambda x.x\ y\ x)\ z)$
      $\longrightarrow$  \\
      $(y\ y\ y)\ (\lambda z.(\lambda x.x\ y\ x)\ z)$

    \item $(\lambda x.x\ x)\ (\lambda x.x\ x\ x)$ $\longrightarrow$ \\
      $(\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)$ $\longrightarrow$ \\
      $(\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)$
      $\longrightarrow$ \\
      $(\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)\ (\lambda x.x\ x\ x)$ $\longrightarrow$ \bot


    \end{enumerate}

  \item{See attached $hw2a.ml$ file.}

  \item{Free Variables Proof}
    \begin{free}
      If FV(\verb|t|) = $\emptyset$ then either \verb|t| is a value or there exists at term \verb|t|$'$ such that \verb|t| $\longrightarrow$ \verb|t|$'$.
    \end{free}

    \textit{Induction Hypothesis.} If FV(\verb|t|$_0$) = $\emptyset$ and \verb|t|$_0$ is a sub-term of \verb|t|, then either \verb|t|$_0$ is a value or there exists at term \verb|t|$'_0$ such that \verb|t|$_0$ $\longrightarrow$ \verb|t|$'_0$.


    \begin{proof}
      We proceed by induction on the structure of \verb|t|:
      \begin{enumerate}
      \item If \verb|t| is a variable $x$, then FV(\verb|t|) is $\{x\}$, a contradiction.
      \item If \verb|t| is an abstraction, $\lambda x.$\verb|t|$_1$ then \verb|t| is a value.
      \item if \verb|t| is an application, $($\verb|t|$_1$ \verb|t|$_2)$, then \verb|t| is not a value and we show that it can take a step. :
        \begin{enumerate}
        \item E-App1: By the inductive hypothesis \verb|t|$_1$ is either a value or
          can take a step, in the latter case E-App1 applies.
        \item E-App2: By the inductive hypothesis \verb|t|$_2$ is either a value or can take a step, the latter case E-App2 applies.
        \item E-AppBeta: Otherwise, by the inductive hypothesis \verb|t|$_1$ and \verb|t|$_2$ are values and E-AppBeta applies.
        \end{enumerate}
      \end{enumerate}
    \end{proof}

  \item{Proof that $\omega$ Steps to Itself}
    \begin{thm}If $(\lambda x.x\ x)\ (\lambda x.x\ x)$ $\longrightarrow*$ $t$,
      then $t$ = $(\lambda x.x\ x)\ (\lambda x.x\ x)$.
    \end{thm}

    \textit{Induction Hypothesis.} If \verb|t|$_0$ $\longrightarrow$ \verb|t|$_0'$ , \verb|t|$_0$ $\longrightarrow$ \verb|t|$_0''$, and \verb|t|$_0$ $\longrightarrow$ \verb|t|$_0'$ is a sub-derivation of \verb|t| $\longrightarrow$ \verb|t|$'$, then \verb|t|$_0'$ = \verb|t|$_0''$.

    \begin{proof}
      The last rule in derivation of $t\ \longrightarrow*\ t$ can be 3 cases:
      \begin{enumerate}
      \item E-Refl: Then it is trivally true.

      \item E-Step:
        The last rule in derivation of $t\ \longrightarrow\ t$ can be 3 cases:
        \begin{enumerate}
        \item E-App1: Then we know $t$ is of form $(t1\ t2)$ and $t_1\ \longrightarrow\ t_1'$.
        \item E-App2: Then we know $t$ is of form $(v1\ t2)$ and $t_2\ \longrightarrow\ t_2'$.
        \item E-AppBeta: Then we know $t$ is of form $(t1\ v2)$.

          \verb|t|$_1$ must take a step to some \verb|t|$_1''$. By the inductive hypothesis, since we know \verb|t|$_1$ steps to both \verb|t|$_1'$ and \verb|t|$_1''$,
          then \verb|t|$_1'$ and \verb|t|$_1''$ must be the same.
        \end{enumerate}


      \item E-Trans: \verb|t|$_1$ must take a step to some \verb|t|$_1'$, and \verb|t| has the form
        \verb|if t|$_1$ \verb|then t|$_2$ \verb|else t|$_3$.


      \end{enumerate}
    \end{proof}

    \newpage

  \item Short circuit \verb|and| and \verb|or|.

    The old definition of \verb|and|:\\

    $and = \lambda a.\lambda b.a\ b\ false$\\

    When $a$ is $true$ it will return the function that takes two arguments and applies the first $thnk$ to the second ``unwrapping'' $thnk$'s contents. If $a$ is $false$ it will return a function that ignores its first argument and return its second, in this case $false$: \\

    $newAnd = \lambda a.\lambda thnk.(a\ (\lambda x.\lambda y.x\ y)\ (\lambda x.\lambda y.y))\ thnk\ false$\\

    The old definition of \verb|or|:\\

    $or = \lambda a.\lambda b.a\ true\ b$\\

    Similar to the above: \\

    $newOr = \lambda a.\lambda thnk.(a\ (\lambda x.\lambda y.y)\ (\lambda x.\lambda y.x\ y))\ thnk\ true$\\

  \item{See attached $hw2b.ml$ file.}
\end{enumerate}

\end{document}
